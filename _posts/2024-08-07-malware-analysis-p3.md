---
layout: post
title: Phân tích mã độc - P3
date: 2024-08-09
subtitle: Malware Analysis Notes (Wall of Text - Part 3)
tags:
- reversing
- malware
--- 
- [Các dạng tài liệu có thể chứa mã độc](#các-dạng-tài-liệu-có-thể-chứa-mã-độc)
  - [PDF](#pdf)
  - [Office Document](#office-document)
  - [RTF (Rich Text File)](#rtf-rich-text-file)
  - [Microsoft Excel 4 (XLM) macro](#microsoft-excel-4-xlm-macro)
- [Các dạng payload được nhúng kèm tài liệu độc hại](#các-dạng-payload-được-nhúng-kèm-tài-liệu-độc-hại)
  - [Các loại script](#các-loại-script)
  - [Pratical Javascript Deobfuscate](#pratical-javascript-deobfuscate)
  - [Shellcode](#shellcode)
- [Các công cụ hỗ trợ phân tích payload trong các file tài liệu](#các-công-cụ-hỗ-trợ-phân-tích-payload-trong-các-file-tài-liệu)
- [Tổng kết](#tổng-kết)

# Các dạng tài liệu có thể chứa mã độc

## PDF
- Là định **dạng document** phổ biến, hay được sử dụng để bắt đầu tấn công người dùng cuối
    - **chứa url độc để phising**
    - **chứa script, file độc** có thể thực thi
    - **chứa lỗ hổng thực thi mã từ xa** để khai thác các phần mềm đọc pdf (foxit, adobe,..)
    - Cấu trúc gồm
        - **header**: chứa **signatrue (%PDF)** và **phiên bản** tệp (ví dụ 1.4, 1.6,..), header có thể **nằm ở bất kì** đâu trong **1024 byte đầu tiên**
        - **object 1**: **nội dung** để hiển thị file pdf, gồm font, ảnh, chữ, **script**,...
        - **object 2**
        - **object n**
        - **xref**: bảng chứa **thông tin** vị trí (**offset**) của **từng object** trong file
        - **trailer**: Chứa **thông tin** về **số lượng object** và **offset của bảng xref** trong file, **object root** và cả các **thông tin metadata**
    - Thông tin **1 object** bao gồm
        -  **obj_id revision obj**: obj_id và revision là 2 thuộc tính để xác định 1 object
        - ... : các thông tin về **thuộc tính, nội dung, liên kết**,.. của object
        - **endobj**
    - Một **object** có thể **liên kết** với **nhiều object** khác
- Các **object** biểu diễn sự **liên kết** với nhau thông qua các "**keyword**", có thể dựa vào **nghĩa của các keyword** để nắm thông tin về object
- Kiểm tra các **keyword dễ bị lợi** dụng để **phishing** hoặc **thực thi code** javascript độc hại
    - Keyword về các **hành động tự động**: tự động thực thi các hành vi độc hại
        - **/OpenAction**: hành động khi mở tập tin
        - **/AA**: (Automatic Action) hành động tự động thực hiện
    - Keyword về **javascript**: Thường gán với các hành động tự động để thực thi code js độc hại
        - **/JS|/JavaScript**: document chứa javascript
        - **/AcroForm**:  Adobe forms, có thể chứa javascript
        - **/XFA**: XML Forms, có thể chứa javascript 
    - Keyword về **thực thi chương trình, file** kèm theo: **phising** lừa **người dùng click** để thực thi mã độc
        - **/Launch**: chứa các action thực thi chương trình kahsc
        - **/EmbeddedFiles**
    - Keyword **tương tác với website**: **Phising** lừa **người dùng truy cập tới** các **site** nguy hiểm (chứa** mã độc**, **giả mạo** đánh cắp thông tin, lừa người dùng **tải xuống mã độc**,..)
        - **/URI**: **url** trong document
        - **/SubmitForm|/GoToR**: **data** được **gửi đến URL**
- Một số **keyword** khác được **sử dụng kết hợp** với các keyword nguy hiểm
    - **/Encrypt**: Object được mã hóa, cần mật khẩu để giải mã (thường cung cấp theo ở thông tin phising)
    - **/Annots**: Các **liên kết có thể click được** (trỏ tới trang, bookmark, file, đường dẫn, url,..)
    - **/FlateDecode**: object nén **zlib/deflate**
    - **stream/endstream**: **bắt đầu và kết thúc** một số dạng dữ liệu của **object** như chữ, ảnh, script, binary,..
    - **/O**: hành động mở pdf
    - **R**: **reference**, thường **theo sau object_id revision** để **chỉ định object muốn tương tác**
    - **/Xobject**: các file **ảnh đính kèm**
    - **/ObjStm**: **object chứa các object khác**

## Office Document
- **Word/Excel/Powerpoint** là các định dạng document phổ biến
    - Hỗ trợ **VBA macro** cho phép kẻ tấn công **thực thi các hành vi nguy hiểm**
        - có thể **tương tác với hệ điều hành**, đọc ghi, tải xuống và thực thi file, **thực thi api, shellcode**
        - có thể **thực thi khi người dùng mở file document**. **Tự động** nếu chế độ hiện tại cài đặt cho phép **macro tự động chạy** hoặc **lừa người dùng click để chạy**
        - Thông thường **mã độc** sẽ làm rối (**obfuscate**) code VBA để **tránh bị phát hiện** và khó phân tích hơn
        - **Macro không được mã hóa** khi mã hóa tài liệu
        - Macro **được lưu** trong tài liệu **ở 2 dạng**, **pcode** và **compressed source code**
    - Các tập tin **có thể** chứa mã khai thác lỗ hổng **RCE**
- Có **2 dạng** file docment của microsoft phổ biến **OLE** và **XML-based (OOXML - zip)**
    - **OLE format**: Định dạng cũ, còn được gọi là **structed storage** hoặc **compound file**, sử dụng strorage (folder) và streams (file) để lưu trữ các file khác bên trong và cho phép chương trình mở, hiển thị nhiều file trong 1 file
    - **XML-based format** được sử dụng từ bản office 2007 hay còn gọi là OpenOfficeXML là **một tập tin nén** chứa các **file XML** để mô tả liên kết với các dữ liệu khác bên trong
        - Có thể **giải nén và xem các file xml** và dữ liệu khác bên trong
    - **Cả 2** dạng **đều có thể chứa macro hoặc mã exploit**
        - Nếu **macro** chứa trong các dữ liệu của định dạng file **XML-based**, chúng **sẽ được lưu ở dạng OLE** (OLE bên trong file OOXML). 
            - Các tập tin **cần có đuôi m (docm, xlsm)** để office nhận biết và xử lí macro
        - Định dạng **OLE chứa macro** luôn được office xử lí **bất kể đuôi** (docx, doc, docm,..)
- Với các **văn bản chứa macro**, thường có các nội dung **phising** để lừa người dùng **bấm nút Enable Content** để macro được thực thi
    - Giao diện của **microsoft word/excel.. có tính năng macro** để xem/debug macro
        - **Cần mật khẩu** để mở các tài liệu được bảo vệ, thường đc gửi kèm theo **nội dung phishing** hoặc hướng dẫn
        - **Thêm lệnh "Debug.Assert False"** vào code macro **để dừng** luồng thực thi sau đó **mở vba macro debugger** và thực thi từng dòng, **đặt breakpoint** và **theo dõi thay đổi** của giá trị các biến
    - Một số **phần mềm khác** như libreoffice cũng **hỗ trợ xem macro** nhưng bị **hạn chế** khi macro thực thi
- **Sử dụng các công cụ khác** để parser có thể **đọc macro** mà không cần password **vì macro không lưu ở dạng mã hóa**
    - **oledump**
    - **olevba**
    - **viper monkey**
- Khi parser bằng công cụ, thường tìm thấy **Macro lưu trong các stream có tên VBA** của tài liệu
    - **Macro** cũng có các** phiên bản cached** được lưu trong **stream tên SRP**
- Các **dấu hiệu macro có thể chứa mã độc**
    - Sử dụng keyword **AutoOpen/Workbook_Open** để tự động thực thi macro khi mở file
    - **Sử dụng các API** để tương tác với OS
    - **Sử dụng** các chức năng nguy hiểm như **Shell/WshShell, exec,..**, tương tác với **dữ liệu remote**
        - **Thực thi exe** bất kì hoặc **dll/msi** thông qua **rundll32**, **regsvr32** hoặc **msiexec (LOLBAS)**
    - **Bị obfuscate**
    - Sử dụng kỹ thuật **VBA stomping** để che giấu source code
        - **Nếu có cả 2 phiên bản** compiled (pcode) và source code (compressed) được lưu trong tài liệu, thông thường **pcode sẽ được thực thi**
            - attacker **xóa bỏ sourcecode** hoặc **thay đổi source code** để tránh bị phát hiện (các tool parse từ source sẽ không thấy macro hoặc thấy source giả)
            - nếu sử dụng **vba stomping**, **macro chỉ thực thi** được khi **chạy đúng phiên bản office tạo ra** macro
        - cần sử dụng công cụ để **trích xuất pcode** và disassemble/decompile
            - sau khi decompile, có thể **phân tích động **bằng cách **chèn decompile code vào 1 file document bất kì**
    - Sử dụng **vba purging** để **xóa pcode** và giữ lại source code
        - **vba** sẽ được **compile từ source sang pcode và thực thi**
- **Ngoài macro**, các thông tin khác từ **metadata** hoặc các **thuộc tính của file tài liệu** cũng có thể chứa **thông tin thiết thực (hoặc là bait)**
  
## RTF (Rich Text File)
- Định dạng được **hỗ trợ bởi ms office** và nhiều phần mềm khác
- Cấu trúc **gồm** nhiều **từ khóa** của **object** và **dữ liệu** của chúng
    - **Dữ liệu** biểu diễn ở **dạng anscii text và hex**
    - Các **từ khóa bắt đầu bằng dấu \\** và **nhóm trong dấu {}**
        - Nhóm có thể **gồm nhiều nhóm nhỏ** bên trong, có thể **chia theo cấp**
- RTF **không chứa macro** nhưng **hỗ trợ nhúng kèm bên trong nhiều loại object** khác nhau 
- Được **lợi dụng để phising** lừa người dùng thực **thi các loại file nhúng bên trong** hoặc có thể **chứa mã khai thác RCE** khi người dùng mở file
- Thông thường sẽ sử dụng công cụ để **trích xuất và phân tích các object bên trong**
    - **Mã độc** thường nằm **trong object có từ khóa \\objdata**, dữ liệu sẽ ở dạng hex string
    - **Mã độc** thường **thêm các dữ liêu khác** vào **phần sau kết thúc file theo header**.
        - **Dữ liệu dư thừa** này thường gọi là **trailer** hoặc **overlay**
    - Các dữ liệu trong **object "Equation Native"** thường xuyên được sử dụng để **chứa mã khai thác Equation Editor**
- Sau khi **trích xuất được (OLE, Shellcode, File thực thi,..)**, sử dụng các phương pháp **tương ứng với định dạng của object** để phân tích
  
## Microsoft Excel 4 (XLM) macro
- Định dạng **macro cũ trên excel** từ 1992 nhưng **vẫn hoạt động** trên các phiên bản excel mới
    - File chứa **XLM macro** thường có đuôi **.xlsm, .xlsb** và thuộc định dạng **OOXML**
    - Trong cấu trúc OOXML, **các stream chứa macro thường có tên "macrosheets"**
- **XLM Macro vẫn nguy hiểm** vì có thể tương tác với OS, gọi api và chạy chương trình
- **XLM macro không nhúng trong các vba object**, XLM macro **nhúng trực tiếp** trong từng ô **ở dạng công thức** ở các sheet
    - Thường **sheet sẽ được ẩn** 
    - Macro sẽ **nhúng ở nhiều ô khác nhau** trong sheet, thường là các ô ở các xa nhau
    - **Text** trong ô được format **màu trắng** để người dùng khó phát hiện
- **Luồng thực thi** của macro thường **nằm ở trong stream "workbook.xml"**
    - Bao gồm **danh sách các sheet** trong thẻ **\<sheets\>\</sheets\>**
        - Sheet thường có các thông tin
            - **name**: Tên sheet
            - **sheetid**: id sheet
            - **state**: trạng thái của sheet (hidden)
            - **r:id**: relationship id, dùng để xác định dữ liệu của sheet trong các **stream relationship (.rels)**. relationship stream tương ứng nằm trong **thư mục \_rels** và có tên trùng với tên stream xml 
                - vd **workbook.xml** tương ứng với **stream \_rels\workbook.xml.rels** 
    - Dựa vào **các thuộc tính của definedName** có thể xác định điểm **bắt đầu thực thi macro**
        - Tìm các **ô có chứa thuộc tính tự động thực thi** bắt đầu bằng **Auto_Open** (cả in hoa và thường) 
- Trong các **stream rels**, thẻ **relationship có 2 trường** để xác định stream ứng với r:id
    - **Id: rid**
    - **Target**: nội dung stream ứng với rid
- **Stream** chứa các **sheet** sẽ bao gồm định dạng **biểu diễn nhiều cột** **\<column\>** (ABCD..) và hàng **\<row\>** (1234) và **ô (A123)**
    - Mỗi **ô nằm trong thẻ \<c\>** và có nhiều thông tin khác kèm theo
        - Các thuộc tính của thẻ \<c\>
            - **r=**: reference vị trí của ô theo hàng cột (c23)
            - **t=**: type dữ liệu của ô:
                - **str**: chứa công thức
                - **b**: boolen
                - **n**: number
                - **s: shared string**: dữ liệu của ô **lưu trong bảng sharedString**
        - Thẻ **\<f\>**: **công thức của ô** có thể chứa lệnh của macro hoặc giá trị
        - Thẻ **\<v\>**: **giá trị của ô**, giá trị xác định cùng với kiểu ở thuộc tính t= của ô
            - **Value** có thể trực tiếp là **text**, **number** hoặc là **index** của 1 string **trong bảng sharestring** được lưu trong **stream sharedStrings.xml**
                - **Mỗi index là 1 chuỗi** trong bảng **được lưu trong thẻ \<si>** của stream sharedStrings.xml
                - **index tính từ 0**
- Khi sử dụng **celltext** để dump các ô bằng **xmldump.py**, output bao **gồm 3 cột**
    - **Reference**: Tên của ô (A123)
    - **Formula**: Công thức chứa macro, dùng để tính giá trị, tạo chuỗi,..
    - **Value**: giá trị cached của ô đó
- Các công cụ **zipdump.py** và **xmldump.py** hỗ trợ **lấy trực tiếp** giá trị từ bảng **sharedStrings.xml** khi dùng **tham số -j**
  
# Các dạng payload được nhúng kèm tài liệu độc hại
## Các loại script
- **Script** được **nhúng trong các file tài liệu** kèm theo nội dung **phising** lừa người dùng mở hoặc tự động thực thi khi mở file
    - **VBA macro**: trong file office
    - **javascript**: trong file **pdf, payload mshta**. trang **web phising**, trang web chứa exploit, 
    - **powershell, vbscript, batch,..**: trong các bước tiếp theo sau khi thực thi, hoặc trong các **shortcut (lnk)**, các file tự giải nén, **payload mshta**
- Cần **đọc và hiểu** cách **script** hoạt động để **xác định hành vi độc hại**
- Script **thường bị obfuscate** để tránh bị phát hiện và làm khó việc phân tích
    -  Các **script bị obfuscate** cũng là dấu hiệu để xác định các script **có thể gây hại**
- Một số **kiểu obfuscate** trong script 
    - **Obfuscate string**:xor, base64, Hex Encode, ASCII encode, Reverse, Replace, Split, Join, ChrA/ChrW..
    - Chèn **comment rác, code rác**
    - Sử dụng **tên** các hàm, biến **tối nghĩa**
    - Sử dụng **dòng code rất dài**
    - **Làm rối luồng thực thi** bằng cách **gọi đến nhiều hàm con**
- **Hướng deobfuscate**
    - Manual
        - **Xác định và xóa bỏ comment, code rác**
        - **Decode** và khôi phục các string **rồi thay thế các chuỗi** bị obfuscate (theo text hoặc regex) bằng text đã decode
        - **Đổi tên** (search and replace) cho có nghĩa các biến, hàm
        - **Split từng lệnh** của dòng code dài
        - Hiểu và **lược bỏ bớt các luồng gọi hàm không cần thiết**
    - Tự động
        - Sử dụng các** kết hợp command, công cụ**, chuyển hướng output của các công cụ qua cho nhau để thực hiện
        - **Code script để tự động** quá trình

## Pratical Javascript Deobfuscate
- Trên windows, **Javascript** được mã độc sử dụng để **thực thi** mã trên hệ thống bằng cách **phishing** người dùng
    - Truy cập các **website độc**, chứa mã js hoặc exploit 
    - **Mở các file tài liệu** (pdf, hta, lnk, bat,..) chứa/thực thi js qua các công cụ
        - **adobe**, foxit,..
        - **mshta**: công cụ đọc hta của windows
        - **cscript/wscript**: công cụ thự thi script của windows
- **Mục đích** của các script
    - **Chuyển hướng**, dẫn dắt **người dùng** đến các website độc
    - **Tải xuống, thực thi** các stage tiếp theo(**exe**, **shellcode**, **powershell**,..)
- Có 2 hướng khi **phân tích js**
    - **Phân tích tĩnh** và deobuscate bằng việc **đọc hiểu code**
    - **Thực thi** và **theo dõi** script trong **môi trường lab**
- Phân tích js 
    - Đối với **js trên trình duyệt**, mã độc hay sử dụng **các tính năng để hiển thị, thay đổi nội dung trang**
        - **document.write**
        - **document.body.appendChild**
        - **document.parentNode.insertBefore**
    - **Mã độc làm rối script** bằng các phương pháp khác nhau
        - random tên biến, hàm
        - syntax phức tạp: 1 dòng, lồng nhau
        - **encode/decode** các giá trị
        - chèn code rác
        - Sử dụng hàm **eval** để thực thi các đoạn mã js sau khi giải mã
    - hàm js có thể dùng để **detect debugger** của trình duyệt: **function anonymous() {debugger}**
    - **JS** có thể **tương tác với hệ điều hành** thông qua object **ActiveXObject** của windows
        - **Wscript.Shell**
            - CreateShortcut (file, url)
            - SpecialFolders
            - **Exec/Run**
            - Reg(Write|Read|Delete)    
        - **Shell.Application**
            - NameSpace
            - **Run**
            - Open
            - **ShellExecute**
            - ServiceStart/Stop
    - **Mã độc** có thể **sử dụng các thành phần ở stage trước** (href, document, header, url,..) **để giải mã các stage tiếp theo**
        - Cần lưu ý **thu thập các thông tin khác kèm theo** của 1 site/request hay tài liệu **khi phân tích động**
    - Mã độc sử dụng **arguments.callee để tự đọc nội dung script** được thực thi
        - Checksum, **kiểm tra tính toàn vẹn** dựa vào nội dung, kích thước,..
        - **Sử dụng** 1/nhiều phần để **giải mã các bước tiếp theo**
        - **Đọc và thay đổi script** để thay đổi cách/hướng thực thi
    - Cần **format code** để dễ đọc hiểu (js-beautify, sử dụng code editor như vs, sublime, notepad++,..)
- Các **lưu ý khi để script thực thi và tự giải mã**
    - Các **interpreter** spidermonkey/cscript/wscript sẽ **thực sự thực thi code js**
    - **interpreter không xử ý các thông tin khác ngoài script** ví dụ như nội dung format trang web (HTML, HTA,..) hoặc tài liệu đính kèm (PDF)
        - Cần **xác định và trích xuất js script** trước khi đưa vào thực thi trong interpreter
            - **extractscripts.py** để lọc script trong thẻ \<script\> trên file html, hta
    - **spidermonkey không chứa các thành phần được định nghĩa bởi windows hay các phần mềm** mở pdf như **ActiveXObject**, **location**, **document**,..
        - Cần **tạo định nghĩa các object bị thiếu** hoặc **định nghĩa lại các object có sẵn** và thực thi **kèm theo script** khi sử dụng **interpreter**
            - Khi định nghĩa, **sử dụng syntax của js**
            - Khi **định nghĩa mới hoặc ghi đè các object** cần lưu ý:
                - **Lưu lại object cũ** nếu đã có
                - **In ra nội dung thực thi** để kiểm tra (**print**, **wsh.echo**,..) rồi mới thực thi object cũ, mục đích **tương tự hook**
                - Cách thực thi object **để script có thể tiếp tục chạy**
    - Các **stage tiếp theo** của js có thể là **binary/shellcode/powershell**,..
- Lưu ý khi **sử dụng AMSI**
    - **cscript/wscript có thể thực thi các object của windows** mà không cần định nghĩa lại 
        - vẫn **có thể thêm code để ghi đè object**
    - **Log** ghi lại **nhiều stage của script khi thực thi** và bao gồm cả các script khác:
        - **Xác định và bỏ qua các script** của os/app **hợp lệ** 
        - **Sử dụng**, chỉnh sửa công cụ **parser output hiển thị** dễ phân tích hơn

## Shellcode
- Là **các đoạn mã máy** có thể **thực thi trực tiếp** (ko cần header như các dạng file thực thi exe, dll), thường **được nhúng** kèm các **trong các mã khai thác** của tài liệu độc hại
- **Mã khai thác** sẽ **thực thi khi khai thác lỗ hổng thành công** các ứng dụng đọc file tài liệu (microsoft office, foxit, adobe,..) hoặc bất kì định dạng file nào
    - Đóng **vai trò trực tiếp thực thi** các hành vi độc hại hoặc **trung gian** để thực thi các hành vi khác (tải xuống file pha sau, remote access,..)
    - Bất kì **phần mềm nào cũng có thể chứa lỗ hổng** và có thể **bị khai thác**. 
  - **Khi khai thác** lỗ hổng phần mềm, có thể có nhiều ảnh hưởng
      - **nâng quyền**
      - **thực thi** mã, phần mềm bất kì
      - **lấy thông tin**
      - ...
- Các **script cũng có thể chứa shellcode** bên trong code và sẽ **có các lệnh** với chức năng **thực thi shellcode** 
- Cần **trích xuất** được Shellcode sau đó **có thể disassemble** và tiến hành phân tích như khi **phân tích code trong file thực thi**
    - Xác định **điểm bắt đầu của shellcode** để thực hiện phân tích
        - **Shellcode** trong payload có thể bắt đầu **từ đoạn mã chứa nhiều byte NOP (0x90) liên tục** trước khi thực thi thật sự
            - Mục đích là để **mã khai thác** có thể **nhảy đến** (không chính xác hoàn toàn) phần đầu của **shellcode** mà vẫn thực thi được **toàn vẹn chức năng** của shellcode
            - nop
            - nop
            - nop
            - ...
            - nop
            - shellcode_code
            - ...
            - 
        - **Shellcode** có thể thực thi ở bất kì địa chỉ nào do đó **chúng cần thực thi các lệnh để lấy địa chỉ hiện tại**, cách phổ biến nhất là sử dụng lệnh **call** và **pop**
            - ..
            - call \[address]
            - ...
            - \\\[address\]: 
                - 
                - ...
                - pop reg
                - ..
        - Vì **ko có bảng IAT** nên **Shellcode cần lấy địa chỉ** của các **hàm API** để thực thi
            - Cách hay dùng là **truy cập TIB->PEB** để tìm **địa chỉ các dll**
                - **TIB trỏ bởi thanh ghi FS**
                - **PEB** nằm ở **offset 0x30** trong cấu trúc TIB
            - Một sô lệnh để **lấy địa chỉ PEB**
                - mov reg, **FS:\[30h\]**
                - mov reg, **fs:\[formula_with_result_equal_0x30]**
                - mov reg1, formula_with_result_equal_**0x30**; mov reg2, **fs:\[reg1\]**
    - Có thể dùng **xorsearch (-W)** để **xác định** các pattern liên quan đến **vị trí bắt đầu** của shellcode
        - Các **pattern** dựa trên **opcode** của các đoạn code **nhiều nop**, code **tìm địa chỉ** hoặc **tìm PEB** 
- Khi **xác định được shellcode** và **vị trí shellcode bắt đầu** thực thi, có thể **sử dụng các công cụ tương ứng để trích xuất và phân tích**

# Các công cụ hỗ trợ phân tích payload trong các file tài liệu
- **file/trid**: Công cụ phát hiện định dạng tập tin
- more|**less**: cho phép xem từng dòng đối với output dài
- **pdfid.py**: Lấy **thông tin tổng quan** về 1 hoặc nhiều file pdf
    - Gồm thông tin phiên bản file PDF, **các keyword của object phổ biến** và số lượng
    - **pdfid.py \[options\] \[pdf-file|zip-file|url|@file\]**
        - -n: ẩn các loại object có số lượng = 0
        - -e hiển thị các metadata
- **pdf-parser.py**: **Phân tích, hiển thị, trích xuất** thông tin về **file pdf và các object trong file** dựa vào cấu trúc file
    - **pdf-parser \[options\] pdf-file|zip-file|url**
        - **-a**: **phân tích và thống kê** các thuộc tính, keyword
        - **-O**: Sử dụng kết hợp để **phân tích** cả các object được nhúng trong các keyword **/ObjStm**
        - **-s**: **search** thông tin **keyword** (-s /URI, -s /Javascript)
        - **-k**: **hiển thị giá trị** của các keyword (-k /URI, -k /JS)
        - **-o**: **xem thông tin về object** theo id (-o \[id\])
        - **-d**: **kết hợp với -o** để **dump object** ra file **theo id** (-o \[id] -d \[filename\])
        - **-r**: **tìm các liên kết** gọi tới object, thường dùng để tìm kiếm các **nội dụng reference tới object chứa mối nguy hại** (-r \[id\])
        - **-f**: Sử dụng các bộ lọc** deflate, lz, asciihex** để đọc dữ liệu từ object 
- Các công cụ **request tới url** để kiểm tra nội dung hoặc tải file
    - lưu ý **đảm bảo an toàn khi kết nối** (**vpn**, **lab** độc lập,..)
    - **curl/wget**
        - nên **sử dụng useragent và các header phổ biến của trình duyệt** phổ thông
            - **wget --header \[option\] \[url]**
            - **curl -H \[option\] \[url]**
    - Pinpoint/Scout/**Honeyclient**
        - cho phép **chỉnh sửa header và nội dung request**, kiểm tra request/response
    - Sử dụng các **trình duyệt mặc định** để truy cập
        - Sử dụng các công cụ **theo dõi hành vi** để phân tích các hành vi sau khi truy cập
        - Theo dõi qua các công cụ như **Fiddler, Burp, wireshark** để phân tích, lưu lại TLS keys để giải mã traffic
    - **Khi truy cập** url độc, có thể thử **truy cập nhiều lần, nhiều profile trình duyệt hoặc nhiều ip** ở các vùng khác nhau để kiểm tra tương tác trả về
- **Fiddler**
    - Cho phép **xem thông tin http/https request**, mỗi request ứng với 1 dòng
        - **thông tin chi tiết** về request/response trong **tab Inspectors**
    - **Export** nội dung trả về của request thành **rawfile** (**File -> Export Sessions -> All Session: Select Rawfile**)
- **zipdump.py**: **Phân tích** nội dung file **zip**, hỗ trợ định dạng **XML-based**
    - **zipdump.py \[options\] \[docx|zip-file|xlsx,..\]**
        - **-s \[index\] -d**: trích xuất các file bên trong dựa vào index
        - **-j: parse sharedString.xml**
- Các công cụ **phân tích shellcode** để phân tích các **payload khai thác RCE**
    - scdbg/**scdbgc**: giả lập shellcode
        - **-f: file shellcode cần thực thi**
        - -s: số lệnh muốn thực thi (-1 = unlimited)
        - **/foff: offset bắt đầu của shellcode (dạng hex)**
        - **/fopen: chỉ định file khi shellcode muốn đọc**
        - /norw: ẩn các api readwrite file nhiều lần
    - **rundbg**: **Thực thi shellcode để debug**, mặc định sẽ suspend shellcode nếu không dùng option -n
        - **runsc -f \<shellcode file\> \[-o <offset\>\] \[-d \<document file\>\] \[-n\]**
    - **speakeasy** giả lập shellcode
- **Oletool**: Bộ công cụ **đọc, phân tích, parser** cho file **OLE và các file tài liệu khác (RTF, OOXML)**
    - **olevba**: **trích xuất và phân tích macro** trong các file tài liệu
        - **olevba \[options\] \<filename\> \[filename2 ...\]**
            - **--decode**/--reveal: **thử deobfusce** các script/string
            - -j: hiển thị kết quả ở dạng json
            - -r: tìm file trong thư mục đệ quy
            - **-z/-p**: **password** cho các file zip
    - **oledump**: **trích xuất và phân tích các dữ liệu** trong các file tài liệu
        - **oledump.py \[options\] \[file\]**
            - **-i**: hiển thị **thông tin các stream dữ liệu** trong file
                - gồm các cột **\<index\> <macro_attribute> \<size\> <macro_compile_size+macro_compress_source_size\> \<name\>**
                - thuộc tính **cảnh báo macro**:
                    - **M/m: chứa macro**
                    - **!: sourcecode và pcode khác nhau (dấu hiệu của vba stomping)**
            - **-s**: **chọn stream** (theo index hoặc dùng a=all) **để dump** dữ liệu, thường **sử dụng kèm** theo các **option (-a/-A ascii dump, -d rawdump, -x hexdump, -S stringdump, -v vbadecompressdump,..)**
                - **Sử dụng hậu tố sau index** (A3s, A2s, A4c,..) để chỉ định dữ liệu đọc từ source hoặc compiled
            - -p: sử dụng plugin để trích xuất dữ liệu. Một số plugin
                - **plugin_biff** --pluginoptions"-x": **phân tích xlm macro** trong dạng OLE
                - **plugin_http_heuristics**: **deobfuscate url** trong macro
- **XLMMacroDeobfuscator**: deobfuscate XLM macro
    - Sử dụng kết hợp với ms excel để hiệu quả hơn
    - **convert giữa các định dạng OLE/OOXML để thử**
- **pcodedmp.py**: **<macro_compile_size+macro_compress_source_size\> \<name\>** từ file chứa VBA macro
    - pcodedmp \[-h\] \[-v\] \[-n\] \[-d\] \[-b\] \[-o OUTPUTFILE\] fileOrDir \[fileOrDir ...\]
- **pcode2cde**: **Dump và decompile pcode** từ file chứa VBA macro
    - pcode2code \[-h\] \[-v\] \[-p\] \[-n\] \[-o OUTPUTFILE\] \[-d\] inputfile
- **EvilClippy**: **gỡ bỏ password** với các file doc (để mở trên word tự động, phân tích hành vi tự động)
- **vipermonkey (vmonkey)**: **Giả lập thực thi code vba**, ghi lại các hàm đã thực thi và phân tích kết quả
    - vmonkey \[options\] \<filename\> \[filename2 ...\]
        - -z: passowrd để giải mã
        - -r: tìm file trong thư mục đệ quy
        - -s: streep code VBA rác
        - -i: chỉ định tên hàm bắt đầu thực thi
        - -o: xuất kết quả ra file định dạng json, mặc định kết quả dạng text print ra stdout
- **Box.js**: **Giả lập thực thi js** trong môi trường **Windows JScript**
    - box-js [command] sample.js sample2.js folders/mySamples ...
        - **--download/fake-download**: cho phép/giả lập truy cập và tải xuống payload trong khi giả lập
        - **--output-dir**: chỉ định thư mục chứa kết qu
        - --fake-script-engine: giả lập tên interpreter 
- **rtfobj/rtfdump.py**: **Phân tích** tổng quan về **file RTF** và trích xuất các object được nhúng ở trong
    - Dữ liệu hiển thị theo bảng, gồm nhiều thông tin như id, level, size
    - rtfdump.py \[options\] \[file\]
        - -O: hiển thị thông tin tổng quan về các object
        - **-s chọn object** dựa vào id 
        - **-d/-x/-a/-H: dump object** ở dạng raw, hex, ascii
- **xmldump.py**: Parse và hiển thị nội dung xml
    - xmldump.py \[options\] command \[\[@]file ...\]
        - command: 
            - text: dạng text thông thường
            - **pretty**: làm đẹp định dạng xml
            - **celltext**: chỉ hiển thị giá trị của các ô trong sheet (đối với excel OOXML)
- format-bytes.py: Hiển thị dữ liệu theo cấu trúc (format dạng module struct của python) hoặc cấu trúc được định nghĩa sẵn (-f name=eqn1)
- **exiftool**: Trích xuất **metadata** của các tập tin
- **yara-rules**: Sử dụng các bộ rule để **xác định/phân loại mã độc**, công cụ dựa vào các pattern trong file
- **Microsoft office**: 
    - **Debug macro**
    - **Convert** giữa các định dạng file hỗ trợ (OLE \<-\>OOXML)
    - **Phân tích động**: chạy macro và theo dõi hành vi
- Các công cụ bổ trợ cho việc **decode/deobfuscate string**
    - **grep**: tìm, chọn dữ liệu theo text/regex
    - **sed**: tìm và thay thế dữ liệu theo text/regex
    - **sort**: sắp xếp dữ liệu (az-za)
    - **re-search.py**: có **sẵn** một số **regex** để match một vài dạng dữ liệu như **ip, url, email**,...
    - **sets.py**: Thự hiện **thao tác với từng dòng** trong 1 file (**join, xor, sort**,...)
    - numbers-to-string.py: Trích xuất các số và convert sang kí tự 
    - **Cybercheft**: mã hóa, giải mã, convert, xử lí dữ liệu..
    - **xor-kpa.py**: khôi phục key từ mã hóa xor **sử dụng know-plaintext**
        - xor-kpa.py \[options\] **filename_or_plaintext \[filename_or_ciphertext\]**
            - -d: xor dữ liệu với key khi tấn công được
            - -x: xor dữ liệu với key (đã xác định được key)
            - sử dụng tag để định nghĩa chuỗi nếu không sử dụng file
                - \\#: dữ liệu chuỗi dạng plaintext
                - \\#h\#: dữ liệu chuỗi dạng hex
                - \\#b\#: dữ liệu dạng base64
    - **base64dump.py**: phát hiện và decode string base64
    - **translate.py**: Chuyển đổi dữ liệu binary bằng command của python, **xor**, rol,..
        - translate.py -o svchost.exe.dec svchost.exe **'byte ^ 0x10'**
- Sử dụng **AMSI (Antimalware Scan Interface)** để **log** lại các command của **script, macro** theo từng bước
    - Hỗ trợ **XLM, VBA macro, powershell, javascript, vbscript**
    - Các **command** sẽ được **log lại liên tục theo từng bước/lệnh** thực thi -\> có khả năng thu được bản **deobfuscate** của **script** đã thực thi
    - Cần cấu hình để xem được **log** của script đẩy qua **Event Tracing for Windows**
        - B1: Chạy command để bật: **logman start** \[**TraceName**\] -p **Microsoft-Antimalware-Scan-Interface**  -o \[OutputFile.etl\] **-ets**
            - **logman** cụ **quản lý ETW** trên windows
            - start \[TraceName\]: bắt đầu chạy 1 collector đã có được chỉ định ở tham số \[TraceName\]  
            - -p **Microsoft-Antimalware-Scan-Interface**: chỉ định provider muốn thu thập log, ở đây chọn **provier cung cấp dữ liệu log của AMSI**
            - -o \[**OutputFile.etl**\]: **Log thu thập được ghi ra file .elt** cùng thư mục, có thể sử dụng các công cụ như Event Viewer hoặc parser như [**Get-AMSIEvent**](https://gist.github.com/mgraeber-rc/1eb42d3ec9c2f677e70bb14c3b7b5c9c) hoặc [**AMSIScriptContentRetrieval.ps1**](https://gist.github.com/mattifestation/e179218d88b5f100b0edecdec453d9be#file-amsiscriptcontentretrieval-ps1)
            - **-ets**: Gửi luôn command tới các ETW Session để **xử lí ngay lập tức**
        - B2: **Thực thi macro/script hoặc file document** chứa mã độc và **chờ đến khi mã độc/script thực thi xong**
        - B3: **Tắt** quá trình thu thập log: **logman stop**  \[**TraceName**\] -ets và sử dụng các công cụ để **kiểm tra file \[OutputFile.etl\]**
  
# Tổng kết
- Các **file tài liệu** thường là công cụ để thực hiện **phising**, bắt đầu tấn công người dùng cuối **nhằm thực thi file/script độc hại**
- Có thể **phân tích** tĩnh, động bằng **công cụ** để **trích xuất IOC** nhanh
- Cần **đọc hiểu, phân tích code** chi tiết để **hiểu** được cách hoạt động của **macro/script**