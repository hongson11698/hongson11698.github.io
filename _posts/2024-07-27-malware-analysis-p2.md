---
layout: post
title: Phân tích mã độc - P2
date: 2024-07-27
subtitle: Malware Analysis Notes (Wall of Text - Part 2)
tags:
- reverseing
- malware
--- 
- [Bắt đầu dịch ngược code](#bắt-đầu-dịch-ngược-code)
- [Assembly 101](#assembly-101)
  - [Giới thiệu x86 assembly](#giới-thiệu-x86-assembly)
  - [Các lệnh ASM cơ bản (ASM References)](#các-lệnh-asm-cơ-bản-asm-references)
  - [Hàm](#hàm)
  - [64 bit asm](#64-bit-asm)
  - [Luồng thực thi của chương trình](#luồng-thực-thi-của-chương-trình)
- [Các nhóm API hay sử dụng trong mã độc](#các-nhóm-api-hay-sử-dụng-trong-mã-độc)
  - [DLL và EXE](#dll-và-exe)
- [Tổng kết](#tổng-kết)

# Bắt đầu dịch ngược code
- Công cụ: 
    - **IDA và Ghidra** là 2 công cụ phổ biến để thực hiện dịch ngược code.
    - Có thể kết hợp Debugger (xdbg, ollydbg,..) để hiểu hoặc nhanh chóng biết mục đích thực thi của hàm, đoạn code.
- Mục tiêu khi dịch ngược
    - Code lifecycle của một chương trình C/C++: 
        - Mã nguồn: Viết bằng ngôn ngữ bậc cao C/C++
        - Compiler: Biên dịch mã nguồn thành các đoạn mã máy ASM (ObjectCode)
        - Linker: Liên kết giữa ObjectCode với các thư viện (động và tĩnh) để tạo ra file thực thi (executable file) 
        - OS Loader: Nạp file thực thi và các thư viện động sau đó thực thi.
    - **Khi dịch ngược, cần phân tích executable file và kết hợp với debugger khi chương trình thực thi để cố gắng hiểu những gì mã nguồn muốn thực hiện**.
        - **Sử dụng comment, thay đổi tên biến, hằng số, địa chỉ, vùng nhớ để code dễ đọc hơn** (gần giống mã nguồn hơn)
    - **Kết thúc việc phân tích khi**:
        - Hết thời hạn, thời gian phân tích
        - Truy vết được hết các hành vi
        - **Có đủ thông tin phục vụ các mục đích** khác nhau
            - IR: IOCs
            - Hunting và TI: IOCs, IOAs, Tatics, Procedures, Attacker Attribute
- Khi phân tích, có thể bắt đầu từ:
    - **Entrypoint** của chương trình
        - Thông thường cần xác định được hàm "main" thay vì các hàm compiler sinh ra
        - Phân tích cả chương trình đòi hỏi nhiều thời gian, công sức
    - **Tìm các đoạn code về hành vi, thông tin đáng chú ý mà phân tích cơ bản thu được và bắt đầu phân tích chi tiết cách thức thực thi các hành vi đó**
        - **API**: Cổng giao tiếp giữa các chương trình (mã độc) với các thành phần (File, Registry, Process, Network,...) của OS và phần cứng (FileSystem, Screenshot, USB,..). Thường sẽ kèm theo tài liệu từ MSDN hoặc trên các trang về lập trình như Stackoverflow,..
            - Thông tin 1 API trên MSDN thường có:
                - API Name: Có thể dựa vào tên để phán đoán mục đích khi gọi API
                - Description: Mô tả chi tiết về API
                - Syntax: Prototype C/C++ của api
                - Parameters: Chi tiết về cac tham số trong prototype cần truyền vào khi gọi API
                - Return Value: Giá trị trả về của API để nhận biết khi thành công hoặc thất bạt
                - References và các thông tin khác: 
            - MS có 2 phiên bản API
                - A version: Các chuỗi sẽ sử dụng CHAR - ANSI
                - W version: Các chuỗi sẽ sử dụng Widechar - Unicode (UTF-16)
        - **String**: Các chuỗi về đường dẫn file, registry, ip, domain
        - Resource: Các đoạn code truy cập resouce trong tập tin thực thi

# Assembly 101

## Giới thiệu x86 assembly
- **Assembly (asm) là code biểu diễn mã máy** của các file thực thi dưới dạng mã đọc được. 
    - Có 2 kiểu **syntax** phổ biến
        - **Intel**: Thường dùng cho x86. Phổ biến hơn trên windows, nội dung phần dưới sẽ dùng syntax này.
        - **AT&T**: Thường dùng cho hệ arm, misp
    - Một chương trình sẽ bao gồm nhiều lệnh asm (instruction)
    - **Luồng thực thi của các lệnh sẽ là tuần tự**, hết lệnh này tới lệnh khác, trừ một số instruction làm thay đổi tuần tự đó.
- **Instruction** là **mô tả các hoạt động tương tác giữa các register và vùng nhớ của chương trình do CPU thực hiện**.
    - 1 instruction trong Intel syntax bao gồm 2 thành phần chính **Operation (bắt buộc) và Operand (có thể không có)**.
    - **Operation** (hay còn gọi với tên mnemonic, opcode) là câu lệnh của instruction, **mô tả hành động chính**
        - Một số câu lệnh thường gặp
            - and, or, xor, not, add, sub, mul, shr/shl, ror/ror
            - call, jz, jump, jnz, test, cmp, ret
            - lea, mov, push, pop, enter, leave 
    - **Operands** là các tham số để câu lệnh thực hiện xử lí dữ liệu
        - Các operands **mô tả và cung cấp tham số để câu lệnh thực thi**. 
        - Thông thường mỗi instruction có từ 0-3 operands
        - Các operand sẽ biểu diễn các chế độ địa chỉ (addressing mode) để câu lệnh biết đọc dữ liệu từ đâu, ghi dữ liệu vào đâu. Có 3 chế độ địa chỉ chính:
            - Register
            - Địa chỉ vùng nhớ (trực tiếp hoặc gián tiếp)
            - Giá trị số học
        - Đa số trường hợp khi có 2 operand, **operand bên trái là đích để ghi dữ liệu, operand bên phải là nguồn đọc dữ liệu**
- Dữ liệu và kiểu dữ liệu trong asm x86
    - Dữ liệu trên x86 thường biểu diễn ở hệ cơ số Heximal (012..def): 
        - Cần biết/hiểu cách convert sang các cơ số khác như decimal (0..9) và binary (01).
    - Giá trị của dữ liệu có thể truy xuất
        - 1 bit: Mỗi bit có giá trị 0 hoặc 1.
        - 4 bit
        - 8 bit
        - 16 bit
        - 32 bit
        - 64 bit
    - Được lưu trữ ở chế độ Little Endian
    - Một số kiểu dữ liệu cơ bản
        - Kích thước 8 bit: byte, char, unsigned char
        - Kích thước 16 bit: short, unsigned short, word
        - Kích thước 32 bit: int, unsigned int, dword
        - **Con trỏ (pointer): Kiểu dữ liệu đặc biệt, giá trị 32 bit.**
            - **Có giá trị là địa chỉ của vùng nhớ khác trong chương trình (reference to, point to)**
            - Có tác dụng truy xuất dữ liệu hiệu quả hơn
        - Hằng số: Các dữ liệu biểu diễn số trực tiếp (1, 4, 16, 0x200, 0x80000001,..)
            - Đối với các hằng số api sử dụng, hằng số sẽ tương ứng với các symbol hoặc kết hợp của các hằng số với nhau
                - HKEY_CURRENT_USER: 0x80000001
                - CREATE_SUSPENDED: 0x00000004
                - CREATE_SUSPENDED | CREATE_UNICODE_ENVIRONMENT: 0x404 (0x00000004 | 0x00000400)
        - Cấu trúc dữ liệu (struct) là các kiểu dữ liệu chưa nhiều thành phần và kiểu dữ liệu cơ bản bên trong
            - Ngôn ngữ asm sử dụng con trỏ và các cách truy cập vùng nhớ để truy cập tới các biến trong cấu trúc dữ liệu
- **Register**
    - Là các ô nhớ truy cập nhanh trên memory
    - Một số register có **mục đích sử dụng cố định**, một số được **dùng với nhiều mục đích khác nhau**, một số được **dùng linh hoạt** tùy vào instruction.
    - Theo dõi register để **nhận biết các tham số, biến và các giá trị trả về của 1 lệnh hay 1 hàm**
    - Các mục đích sử dụng phổ biến của thanh ghi (32bit):
        - eax: Lưu các giá trị trả về của các hàm
        - ecx: Dùng làm giá trị đếm (index, counter)
        - ebp: Dùng làm điểm mốc để trỏ tới các biến hoặc tham số
        - esi/edi: Dùng trong các lệnh hoặc nhóm lệnh liên quan đến copy/thay đổi giá trị vùng nhớ
        - ebx, edx,..: Dùng trong tính toán, lưu trữ tạm thời,..
    - Các thanh ghi đặc biệt
        - esp: Con trỏ trỏ tới vùng nhờ gọi là đỉnh stack
        - eip: Thanh ghi chứa địa chỉ của lệnh tiếp theo sẽ thực thi
        - eflags: Thanh ghi bao gồm nhiều bit, thường sẽ chứa kết quả của các phép tính toán, so sánh. CPU sẽ thực thi dựa vào giá trị một số flag trong thanh ghi.
            - ZF: Zero Flag, được set = 1 khi tính toán có kết quả = 0 và ngược lại
            - CF: Carry Flag, được set = 1 khi tính toán không dấu vượt quá giới hạn của dữ liệu đầu vào
            - SF: Sign flag, được set = 1 khi tính toán có kết quả âm
            - OF: Overflow flag, được set = 1 khi giá trị tính toán có dấu vượt quá giới hạn của dữ liệu đầu vào
        - Segment: Các thanh ghi chỉ định các thành phần vùng nhớ khác nhau
            - cs (Code segment): vùng nhớ chứa code 
            - ds (Data segment): vùng nhớ chứa data
            - fs: Thread information block (windows)
            - gs: Thread local storage (windows)
    - **Kích thước thanh ghi trong cấu trúc 32 bit là 1 dword**.
        - Có thể truy cập trực tiếp tới các giá trị 16 bit, 8 bit của các thanh ghi. 
            - e?x: Thanh ghi 32 bit, ? là kí hiệu cho các thanh ghi khác(eax, ebx, edx, ecx,..)
            - ?x: 16 bit thấp của thanh ghi
            - ?l: 8 bit thấp của ?x
            - ?h: 8 bit cao của ?x
- **Stack**
    - Là **vùng nhớ tạm thời** của chương trình khi thực thi để **lưu trữ dữ liệu như biến nội bộ, tham số, và các giá trị khác khi cần**
    - Stack **tổ chức theo dạng dữ liệu Last In First Out (LIFO)**. Thông thường chương trình sẽ chỉ truy cập dữ liệu tại "đỉnh" của stack
        - Đọc từ đỉnh stack: pop
        - Ghi vào đỉnh stack: push 
        - Trên hệ x86, mỗi lần đọc/ghi đỉnh stack, giá trị đọc/ghi là 1 dword 
        - esp là thanh ghi lưu lại giá trị địa chỉ "đỉnh" stack
    - Theo chiều từ **đáy -> đỉnh** của vùng nhớ stack, **địa chỉ sẽ giảm dần**
        - Đáy stack thường sẽ giữ nguyên
        - Đỉnh stack thay đổi khi dữ liệu được ghi vào stack hoặc đọc từ stack ra.
            - Ghi thêm dữ liệu vào stack: địa chỉ đỉnh stack giảm đi hay esp giảm đi
            - Đọc dữ liệu từ stack: địa chỉ đỉnh stack tăng lên hay esp tăng lên
    - Mỗi một **hàm** sẽ có 1 vùng nhớ stack gọi là **stack frame**, được thiết lập khi bắt đầu chạy các lệnh đầu tiên trong hàm.
- Con trỏ và truy cập địa chỉ
    - Thuật ngữ để gọi hành động khi **truy cập tới 1 vùng nhở trỏ bởi con trỏ**, này là "**dereferencing**". Ví dụ con trỏ A trỏ tới vùng nhớ 0x1000 (A=0x1000). Khi truy cập dữ liệu vùng nhớ này qua con trỏ A được gọi là dereferencing A.
    - Có nhiều cách để **truy cập vùng nhớ qua địa chỉ** (đối với con trỏ)
        - Trực tiếp
            - Syntax thường gặp là \[0x1000\]: Truy cập dữ liệu tại địa chỉ 0x1000
        - Gián tiếp, sử dụng địa chỉ sau khi tính toán (**effective address - EA**):
            - Công thức tính: **Base + (index\*scale) + displacement** (\[eax + ecx \* 2 + 2])
                - Base: Thường là các con trỏ được lưu vào thanh ghi eax, edx, esi, edi,..
                - Index: Thường là một thanh ghi khác chứa giá trị counter, index
                - Scale: Giá trị (tính theo byte) ứng với mỗi thành phần của con trỏ, ví dụ con trỏ byte mỗi thành phần là 1 byte (scale = 1), con trỏ dword, mỗi thành phần là 1 dword (scale = 4)
                - Displacement: Giá trị tính theo byte, vị trí tương đối so với giá trị base.
            - Có thể sử dụng **kết hợp một và nhiều thành phần trong công thức**
                - Base (edi)
                - Base + displacement (edi+4)
                - Base + index * scale (edi + 2\*4)
                - Base + index * scale + displacement (edi + 2\*4 + 2)
    - Khi dịch ngược, **xác định kiểu dữ liệu và cấu trúc dữ liệu của các biến, vùng nhớ, địa chỉ**
        - Nhận biết và dựa vào **cách dữ liệu, biến, vùng nhớ, con trỏ được sử dụng như thế nào, mục đích gì**
        - Nếu dữ liệu được xử lí bởi các api, có thể **dựa vào tài liệu mô tả api để xác định kiểu dữ liệu**
        
## Các lệnh ASM cơ bản ([ASM References](https://www.felixcloutier.com/x86/))

- Nhóm lệnh tương tác với dữ liệu, vùng nhớ, thanh ghi
    - Là **các lệnh đọc/gán dữ liệu cho thanh ghi, vùng nhớ hoặc đỉnh stack**
    - **push value**
        - Gán value vào đỉnh stack 
        - Giảm địa chỉ đỉnh stack (esp giảm)
    - **pop address**
        - Lấy dữ liệu từ đỉnh stack và lưu vào address
        - Tăng địa chỉ đỉnh stack (esp tăng)
    - **mov dest, src**: gán giá trị src vào dest
        - thực thi tùy vào operand
            - dest thường là thanh ghi, địa chỉ vùng nhớ
            - src thường là thanh ghi, địa chỉ vùng nhớ hoặc các giá trị số học
    - **movs**: gán dest là địa chỉ trong edi, src là địa chỉ trong esi và thực hiện như mov dest, src
    - **lea reg, address**: tính toán địa chỉ trong src và lưu vào reg
        - address thường là 1 công thức để tính toán effective address 
    - **xchg dest, src**: đổi giá trị của dest và src cho nhau
    - **enter n, 0**: Tương đương với các lệnh sau để thiết lập stack frame khi bắt đầu hàm
        - push ebp
        - mov ebp, esp
        - nếu n > 0, sẽ thực thi thêm lệnh sub esp, n
    - **leave**: Tương đương với lệnh để khôi phục stack frame khi kết thúc hàm
        - mov esp, ebp
        - pop ebp
- Nhóm lệnh xử lí dữ liệu
    - Các **lệnh xử lí dữ liệu được dùng khi tính toán**.
    - Các lệnh này đều **thay các cờ** trong thanh ghi **EFLAGS tùy thuộc vào kết quả phép tính**.
    - Xử lí số học
        - **Add dest, src**: dest = dest + src
        - **Sub dest, src**: dest = dest - src
        - **Mul value**: thực hiện nhân eax với value (eax = eax * value hoặc edx:eax = eax * value nếu giá trị eax * value > 32 bit, tương tự với 8 bit, 16 bit)
    - Xử lí logic
        - **And dest, src**: dest = dest & src
        - **Or dest, src**: dest = dest | src
        - **Xor dest, src**: dest = dest ^ src
        - **Not dest**: dest = not dest (đảo giá trị các bit của dest)
    - Xử lí bit
        - **Shr/shl dest, n**: Dịch bit của dest về bên phải/trái n lần (không quan tâm bit dấu)
        - **sar/sal dest, n**: Dịch bit của dest về bên phải/trái n lần (giữ lại bit dấu)
        - **ror/rol dest, n**: Xoay bit của dest về bên phải/trái n lần
        - **rcl/rcr dest, n**: Xoay bit của dest và cả cờ CF về bên phải/trái n+1 lần
- Nhóm lệnh phân nhánh và điều kiện
    - Do chương trình thực thi tuần tự và thực hiện phân nhánh thay đổi luồng thực thi nên **mỗi một đoạn code trước khi phân nhánh được gọi là "basic block"**
        - Cần hiểu các lệnh phân nhánh để hiểu được luồng thực thi của cả chương trình
    - Các lệnh phân nhánh có 2 loại: **phân nhánh khi có điều kiện** và **phân nhánh không cần điều kiện**
        - Việc thay đổi luồng thực thi khi gọi một hàm hoặc trở về từ 1 hàm cũng được coi là phân nhánh
    - **Phân nhánh có điều kiện**
        - Việc phân nhánh **diễn ra khi có các điều kiện thỏa mãn**. Nếu điều kiện không thỏa mãn, chương trình tiếp tục thực thi tuần tự lệnh tại địa chỉ tiếp theo.
        - **Điều kiện** sẽ dựa trên **các cờ trong thanh ghi EFLAGS**
            - EFLAGS thay đổi khi chương trình thực thi các lệnh tính toán trong nhóm lệnh xử lí dữ liệu
            - **Một số lệnh khác làm thay đổi EFLAGS mà không làm thay đổi dest, src**
                - **cmp dest, src**: so sánh dest và src bằng phép trừ (tương tự lệnh sub)
                    - Thường dùng để so sánh lớn hơn/nhỏ hơn hoặc bằng
                - **test dest, src**: so sánh dest và src bằng phép boolean and (tương tự lệnh and)
                    - Thường dùng để so sánh bằng nhau, bằng 0 hoặc khác 0.
        - Thường sẽ cần **phân tích lệnh tính toán hoặc so sánh trước khi lệnh jump có điều kiện** được thực thi để biết điều kiện phân nhánh
        - Các kí hiệu của lệnh jump có điều kiện
            - **A/B: Above/Below**, dùng khi so sánh **không dấu**
            - **G/L: Greater/Less**, dùng khi so sánh **có dấu**
            - **E/N/Z: Equal/Not/Zero**: Dùng độc lập hoặc kết hợp với A/B hoặc G/L
        - **So sánh với 0**
            - **jz/je address**: đặt eip = address khi ZF = 1 (dest = src, dest = 0)
            - **jnz/jne address**: đặt eip = address khi ZF = 0 (dest != src, dest != 0)
        - **So sánh lơn/nhỏ với số không dấu**
            - **ja address**: đặt eip = address khi CF = 0 và ZF = 0 (dest > src)
            - **jae address**: đặt eip = address khi CF= 0 (dest >= src)
            - **jb address**: đặt eip = address khi CF = 1 (dest < src)
            - **jbe address**: đặt eip = address khi CF = 1 hoặc ZF = 1(dest <= src)
        - **So sánh lớn/nhỏ với số có dấu**
            - **jg address**: đặt eip = address khi ZF = 0 và SF = OF (dest > src)
            - **jge address**: đặt eip = address khi SF=OF (dest >= src)
            - **jl address**: đặt eip = address khi SF != OF (dest < src)
            - **jle address**: đặt eip = address khi ZF=1 hoặc SF != OF (dest <= src)
    - **Phân nhánh không điều kiện**
        - Việc phân nhánh **diễn ra luôn khi lệnh được thực thi**
        - Các lệnh phân nhánh không điều kiện hay gặp
            - **jmp address**: Đặt eip bằng address để tiếp tục thực thi instruction tại address
            - **call address**
                - Đưa địa chỉ của lệnh sau lệnh call vào stack, địa chỉ này được gọi là địa chỉ trở về (return address)
                - Đặt eip để tiếp tục thực thi tại address 
            - **ret**
                - Lây giá trị trên đỉnh stack ra (esp sẽ tăng lên). Thông thường, địa chỉ này là return address được đưa vào bởi lệnh call
                - Đặt eip là dữ liệu vừa lấy từ đỉnh stack để tiếp tục thực thi tại đó
    - Đa số các lệnh **call/jump/jnz/jg**... tới address hay gặp **sử dụng địa chỉ tương đối** thay vì giá trị trực tiếp của address
        - Việc sử dụng địa chỉ tương đối giúp chương trình thực thi khi address base thay đổi
        - Khi disassembly ghidra, ida sẽ hiển thị address trong lệnh, tuy nhiên address này đã được tính toán để hiển thị ra
            - **address = eip + x + kích thước của lệnh call**
            - x (-/+) là khoảng cách tương đối tới address
        - **address là địa chỉ trực tiếp** nếu được truyền qua **thanh ghi** (**jmp ecx, call eax**,..)
- Dữ liệu Operand thường gặp cho **src, dest, n thường là register, effective address hoặc giá trị trực tiếp** tùy vào lệnh.
    - Làm nhiều và quen với các operand của các lệnh
    - Tra cứu tài liệu khi gặp
  
## Hàm
- Hàm là **tập hợp nhiều lệnh** để thực hiện một hoặc nhiều việc
    - Tiết kiệm thời gian lập trình, giảm code lặp đi lặp lại
    - **API** cũng là các hàm, nhưng **là hàm của OS** do đó đa phần chỉ cần **quan tâm đến mục đích của api** thay vì phân tích cách hàm api đó thực hiện như thế nào
    - Hàm có **3 thành phần**: 
        - **input**: tham số, dữ liệu truyền vào cho hàm
        - **body**: đoạn code thực hiện công việc của hàm và xử lí input
        - **return**: kết quả sau khi thực hiện công việc được trả về cho caller - đoạn code thực hiện gọi đến hàm
    - **Khi gọi hàm**
        - **Hàm gọi (caller) chuẩn bị các tham số** cho hàm bằng cách đưa vào **stack hoặc thanh ghi**
        - **Địa chỉ tiếp theo** sau lệnh gọi hàm **được lưu vào stack**
        - eip được gán là địa chỉ vùng nhớ chứa đoạn code của hàm và luồng của chương trình thực thi tiếp tục tại vùng nhớ đó. 
        - Phần đầu của **hàm được gọi (callee)** thường thực hiện:
            - **tạo stack frame**, **ebp mới** để làm con trỏ cho hàm **truy cập các biến, tham số**
            - **lưu trạng thái của các thanh ghi**
    - **Sau khi thực thi xong**:
        - **Hàm được gọi (callee)** chuẩn bị **trả về** một giá trị qua thanh ghi **eax**
        - **Trở về đoạn code đã gọi hàm** dựa vào **địa chỉ đã được lưu** lúc hàm được gọi.
        - Phần kết thúc của **hàm được gọi (callee)** thường thực hiện:
            - **khôi phục các thanh ghi** đã lưu
            - **Khôi phục stack frame, ebp cũ**
- **Stack layout**
    - Stack được **dùng để truyền tham số và lưu các dữ liệu** trong quá trình gọi hàm và thực thi của hàm.
    - **esp** trỏ tới **đỉnh stack** thay đổi liên tục, do đó hàm sẽ thường sử dụng **ebp (frame pointer)** làm 1 con trỏ **mốc cố định** khi hàm thực thi **để truy xuất dữ liệu trong stack**
    - Do **esp giảm dần** khi có thêm **các giá trị được đưa vào stack**, các **tham số sẽ nằm ở stack có địa chỉ cao hơn các biến**.
    - Do stack thay đổi, các hàm được gọi lại sử dụng số lượng biến tham số khác nhau nên cần thiết lập stack frame layout để hàm có thể trở về đúng luồng thực thi.
    - Khi thiết lập layout cho stack, **ebp** được gán bằng địa chỉ **lưu ebp cũ** và stack có layout dạng
        - ...
        - biến cụ bộ (ebp-8)
        - biến cục bộ (ebp-4)
        - ebp cũ (ebp của hàm sẽ là địa chỉ này)
        - địa chỉ trở về (ebp + 4)
        - tham số (ebp+8)
        - tham số (ebp+0xc)
        - ...
- Hàm được thiết lập tham số và gọi theo các chuẩn **calling convention**. 
    - Đa số sẽ **dùng lệnh push** để **đưa tham số vào stack**
- Có nhiều chuẩn khác nhau, một số chuẩn chung được áp dụng nhiều:
    - **cdecl**
        - **tham số** truyền theo **thứ tự từ phải qua trái** (tham số đầu tiên được đưa vào stack cuối cùng và ngược lại)
        - **giá trị trả** về lưu tại **eax**
        - hàm **caller** sẽ lấy các tham số khỏi stack (tăng stack lên) sau khi thực thi xong **(cleanup stack)**
    - **stdall** 
        - **khác biệt với cdecl** là **callee** sẽ tự xóa các tham số ra để khôi phục stack **(cleanup stack)**
        - các hàm **api trên windows** sử dụng chuẩn này
    - **fastcall**
        - **tham số đầu** lưu trong **ecx**, **tham số thứ 2** lưu trong **edx**
        - c**ác tham số còn lại đưa vào stack theo thứ tự từ phải qua trái** (tham số thứ 3 được đưa vào stack cuối cùng)
        - **callee** tự lấy tham số ra để **khôi phục stack**
    - **thiscall**
        - sử dụng trong **c++**, với **this** là đối tượng đang được gọi (this)
        - với **msvc compiler**
            - con trỏ tới đối tượng **(this)** được lưu trong **ecx**, các tham số truyền từ phải qua trái
            - **callee** tự lấy tham số ra khỏi stack
        - với **gnu compiler**
            - con trỏ tới đối tượng **(this) được đưa vào stack cuối cùng**, sau khi đã đưa hết các tham số vào stack theo chiều từ phải qua trái
            - **caller** lấy tham số ra khỏi stack
- Một số **tối ưu** của compiler **khi truyền tham số**
    - sử dụng **mov với dest là reference từ đỉnh stack** để đưa tham số vào stack
        - điều kiện là sẽ có các lệnh khác thêm vào để **giữ đỉnh stack trước và sau khi gọi hàm được bảo toàn** vì mov ko làm giảm stack như push
    - sinh ra **Inline-code** cho các hàm function được dùng ít lần
        - Inline là các hàm không cần thiết lập stack layout hay truyền tham số
        - đoạn code của hàm sẽ được chuyển sang code tương thích với caller để thực thi luôn chức năng
- Sử dụng tính năng **find reference** to address, function trong IDA, ghidra **để biết các đoạn mã gọi tới hàm, api**

## 64 bit asm
- Mã độc 64 bit đang ngày càng phổ biến
    - Nhược điểm là mã **64 bit không thực thi được trên 32 bit**
- Lưu ý khi thực thi 32 bit trên OS 64 bit
    - **32 bit** sẽ **dùng thư viện** riêng trong thư mục **syswow64** thay vì system32 như 64 bit
    - Thông thường các **chương trình 32 bit** sẽ **được chuyển hướng** tới khóa registry **Wow6432Node khi truy cập registry**
    - Các **truy cập tới file** trong thư mục system32 và program file **cũng được chuyển hướng** tới **syswow64** và **program file x86**
- Các khác biệt chính
    - Các **thanh ghi** được mở rộng lên **64 bit** (eax -> rax, eip -> rip,...)
    - có **thêm** một số thanh ghi **r8 r9... r15**
    - Mã **64 bit** sử dụng **calling convention riêng** khi gọi hàm
        - **4 tham số** đầu tiên được đưa vào **rcx, rdx, r8, r9**
        - **các tham số còn lại đưa vào stack** theo chiều từ phải qua trái
    - Việc xác định số lượng tham số của hàm trên 64 bit khó hơn
        - cần **dựa vào cách hàm sử dụng các thanh ghi**, giá trị trên stack **để xác định số lượng tham số**
      
## Luồng thực thi của chương trình
- Các cấu trúc luồng thực thi cơ bản trong chương trình gồm phân nhánh **(if-else)**, vòng lặp **(loop)**, **kết hợp điều kiện** và **switch jump table**
- **If else**
    - Là cấu trúc đơn giản nhất **gồm 3 khối lệnh**
        - **khối lệnh kiểm tra điều kiện** và phân nhánh dựa trên kết quả của điều kiện
        - **khối lệnh thực thi khi điều kiện đúng** (của block1), thực hiện jump để bỏ qua khối lệnh của block 2
        - **khối lệnh thực thi khi điều kiện so sánh sai** (của block2).
        - Ví dụ
            - cmp eax, 1 
            - jnz block2 
            - block1:
                - mov eax, ecx
                - ...
                - jmp continue_address
            - block2:
                - mov eax, ebx..
                - ...
            - continue_address:
                - add eax, 1
                - ..
- **if else if else.**..
    - Tương tự cấu trúc if else
    - Nhưng **chứa nhiều khối lệnh kiểm tra điều kiện** và **nhiều khối lệnh ứng với mỗi điều kiện đúng**
    - Lệnh **jmp mỗi khi điều kiện sai** sẽ **trỏ tới khối lệnh kiểm tra điều kiện tiếp theo**.
    - Ví dụ
        - check1:
            - cmp eax, 1 
            - jnz check2 
        - block1:
            - mov eax, ecx
            - ...
            - jmp continue_address
        - check2
            - cmp eax, 2
            - jnz block3
        - block2:
            - mov eax, ebx..
            - ...
            - jmp continue_address
        - block3:
            - mo eax, edx
            - ...
        - continue_address:
            - add eax, 1
            - ..
- **Loop**
    - Là khối lệnh **được thực thi nhiều lần đến khi có điều kiện xảy ra để kết thúc**
    - Lệnh loop/rep
        - **loop address**: 
            - kiểm tra **ecx**, nếu **ecx != 0** sẽ **giảm ecx** đi 1 và **tiếp tục thực thi tại address** 
            - Ví dụ đoạn code dưới đây thực thi 5 lần 2 lệnh add eax, ebx và sub ebx, 1 sau đó gán eax vào vùng nhớ có địa chỉ nằm trong edi
                - mov ecx, 5
                - address:
                    - add eax, ebx
                    - sub ebx, 1
                    - loop address
                - mov \[edi\], eax
        - Lệnh **rep thực thi 1 instruction nhiều lần**, mỗi lần thực thi sẽ **giảm ecx** đi 1, cho **đến khi ecx = 0**
        - Ví dụ gán byte tại địa chỉ trong edi = byte tại địa chỉ trong esi 5 lần 
            - mov ecx, 5
            - rep movsb
    - Ngoài ra asm sử dụng lệnh jump có điều kiện để cấu tạo nên vòng lặp, 
        - Đoạn code **vòng lặp** có **5 phần**
            - **biến điều kiện**: 1 hoặc nhiều biến cần kiểm tra khi thực hiện xong 1 vòng các đoạn code (xác định vào khối lệnh kiểm tra điều kiện)
            - **khối lệnh khởi tạo**: thiết lập giá trị ban đầu cho biến điều kiện
            - **Khối lệnh của vòng lặp**: các lệnh sẽ thực thi trong vòng lặp
            - **Khối lệnh cập nhật giá trị của biến điều kiện** mỗi **khi thực hiện hết 1 vòng** 
            - **Khối lệnh kiểm tra điều kiện kết thúc** vòng lặp
        - Ví dụ vòng lặp thiết lập biến điều kiện a = 0, sau đó kiểm tra nếu điều kiện a >= 5 sẽ thoát vòng lặp, nếu a < 5 sẽ thực hiện khối lệnh của vòng lặp trong loop_body. Sau khi thực thi xong body, thực hiện cập nhật biến điều kiện a và jump đến đoạn code kiểm tra tiếp tục vòng lặp
            - begin:
                - mov eax, 0
            - check1:
                - cmp eax, 5
                - jge end_loop
            - loop_body:
                - add ebx, edx
                - ...
                - add eax, 1
                - jmp check1
            - end_loop
                - ...
        - Một số lưu ý để **xác định các thành phần khi phân tích đoạn loop**:
            - Xác định **khối lệnh điều kiện để kết thúc** vòng lặp **dựa vào lệnh jump có điều kiện về địa chỉ trước**.
            - Xác định **biến điều kiện** dựa vào **lệnh kiểm tra điều kiện** ở khối lệnh điều kiện
            - Xác định **khối lệnh khởi tạo** và **khối lệnh cập nhật biến điều kiện** dựa vào **các lệnh thay đổi dữ liệu biến điều kiện**
            - Xác định các đoạn code còn lại trong vòng lặp
- Kết hợp các điều kiện
    - Thông thường không chỉ có 1 mà sẽ **có nhiều điều kiện được kiểm tra**
        - Điều kiện kết hợp **và**
            - a > 5 && a < 10
        - Điều kiện kết hợp **hoặc**
            - a != 0 || b != 0
    - Nhóm các lệnh kết hợp điều kiện thường có 2 vùng code: Vùng code khi điều điện thỏa mãn (block1) và vùng code không thỏa mãn (end).
    - Khi kết hợp điều kiện, sẽ **có các lệnh jump đến cùng 1 địa chỉ**. Đó có thể là dấu hiệu nhảy đến **block1** hoặc **end**.
        - **với kết hợp và**
            - có nhiều code **cùng nhảy đến end khi điều kiện sai** (luồng thực thi sẽ nhảy đến vùng code không thỏa mãn) và không kiểm tra các điều kiện khác khi gặp điều kiện sai
        - **với kết hợp hoặc**
            - có nhiều code **cùng nhảy đến block1 khi điều kiện đúng** (luồng thực thi sẽ nhảy đến vùng code thỏa mã) và không kiểm tra hết các điều kiện khác khi gặp điều kiện đúng
- Switch sử dụng jump table
    - **Switch case** tương tự như if else if else. So sánh và **kiểm tra giá trị của 1 biến**, thực thi từng **case (vùng code ứng với mỗi biến)**
    - Compiler hay sử dụng **jump table** để làm đích đến với **mỗi case**
    - Jump thường được truy cập với dạng **table\[variable\*4\]**
        - **jump table** chứa nhiều **địa chỉ trỏ đến các vùng code của từng case**
        - **variable** là biến được sử dụng làm **index để truy cập các case trong table**
        - 4 là kích thước 1 phần tử trong bảng table trên hệ thống x86
    
# Các nhóm API hay sử dụng trong mã độc
## DLL và EXE
- **DLL** là các **thư viện động chia sẻ code** giữa các chưng trình, **có định dạng PE** giống như EXE
    - Có 1 cờ để phân biệt trong PE Header
    - DLL thường có **export table** với nhiều hàm để các chương trình khác có thể gọi
    - Mã độc thường nằm ở trong **các hàm export** và **cần được gọi thông qua rundll32 hoặc qua 1 loader riêng**
- API của windows được cung cấp qua các DLL, mỗi dll sẽ bao gồm nhiều hàm được export với nhóm chức năng riêng
- Các dll hay gặp
    - kernel32.dll, advapi32.dll, wininet.dll, ws2_32.dll, user32.dll, shell32.dll, ntdll.dll, msvcrt.dll
- **Các hàm về xử lí chuỗi**
    - strcat, lstrcat, strlen, strcmp, lstrcmp,..
    - sprintf, wsprintf,..
- **HTTP/Internet/Winsock**
    - InternetOpenUrl
    - InternetOpen/Connect/QueryDataAvailable/ReadFile
    - HttpOpenRequest/SendRequest
    - WinHttpOpen/Connect/OpenRequest/QueryDataAvailable/ReadData
    - WSAStartup
    - getaddrinfo/gethostbyname
    - htons/inet_addr/inet_ntoa/ntohs
    - socket
    - bind/listen/accept/connect
    - send/recv
- **Registy**
    - RegOpenKey
    - RegEnumKey/Value
    - RegQueryKey/Value
    - RegSetValue
- **Filesystem**
    - CreateFile
    - ReadFile
    - WriteFile
    - ShFileOperation
    - CreateFileMapping
    - MapViewOfFile
- **Process**
    - ShellExecute
    - CreateProcess
    - WinExec
- **Resource**
    - FindResource
    - LoadResource
    - SizeOfResource
    - LockResource
- **Keylogger**
    - SetWindowsHookEx
    - GetKeyState/GetAsyncKeyState
    - GetWindowsText
    - OpenClipboard
    - GetClipboardData
- **Encryption**
    - CryptAccquireContex
    - CryptGenKey/ImportKey/ExportKey
    - CryptEncrypt/Decrypt
    - CryptCreateHash/HashData/SetHashParam
- **Mutex/Event**
    - CreateMutex/OpenMutex
    - CreateEvent/OpenEvent
    - WaitForSignalObject
- **Memory managerment/Shellcode execute/Process Injection**
    - malloc/HeapAlloc/VirtualAlloc/free/VirtualFree
    - VirtualQuery/VirtualProtect
    - memcpy
    - CreateThread
    - OpenProcess
    - ReadProcessMemory/WriteProcessMemory
    - CreateRemoteThread/QueueUserAPC
    - ResumeThread
- **Others**
    - **LoadLibrary/GetProcAddress**
    - FindFirstFile/FindNextFile
    - ExpandEnvironmentStrings
    - GetTempPath/CreateDirectory/GetFileAttributes
    - GetCommandLine
    - CreateToolhelp32Snapshot/Process32First/Process32Next/Module32First/Module32Next/Thread32First/Thread32Next
    - **NtQueryInformation**
    - CreateNamedPipe/ConnectNamedPipe

# Tổng kết
- Không có checklist hay thứ tự thực hiện phân tích code cố định
- Việc **phân tích** để hiểu một chương trình là **1 quá trình lặp lại liên tục**
    - Dựa vào thông tin **đã biết** -> **phân tích** code -> **tăng thông tin đã biết** -> **phân tích thêm** -> tăng thêm thông tin đã biết .....
- Có thể **dựa vào kết quả phân tích tĩnh/phân tích hành vi** để bắt đầu phân tích. Sau đó có thể **dựa vào các reference** tới các api, hàm liên quan **để phân tích thêm** các vùng code khác.
- Sử dụng **debugger** có thể biết mục đích của hàm để **tiết kiệm thời gian khi không cần phân tích chi tiết**
    - xác định **input** -> **sử dụng debuger** cho chương trình thực thi hàm -> **kiểm tra giá trị trả về và các thay đổi đối với input** -> xác định được mục đích của hàm.
- Sử dụng **seach** để tìm kiếm thông tin về api, assembly trong khi phân tích
- **Lưu lại** những gì đã biết/đã phân tích **qua comment**, đổi **tên biến, hàm, địa chỉ**