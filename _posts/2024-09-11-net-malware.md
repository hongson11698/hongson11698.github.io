---
layout: post
title: Phân tích mã độc  - P6
date: 2024-09-11
subtitle: .NET Malware Analysis Notes (Wall of Text - Part 6)
tags:
- reversing
- malware
--- 
- [Tổng quan về .NET PE](#tổng-quan-về-net-pe)
  - [.NET framework](#net-framework)
  - [Định dạng PE file của .NET executable](#định-dạng-pe-file-của-net-executable)
- [Phân tích .NET malware](#phân-tích-net-malware)
- [Tài liệu tham khảo](#tài-liệu-tham-khảo)

# Tổng quan về .NET PE
## .NET framework
- Do **Microsoft** phát triển nhằm phát triển ứng dụng **đa nền tảng** hệ điều hành
- **.NET Core (.NET 5)** là phiên bản khác của .NET framework
    - Cung cấp môi trường để ứng dụng có thể **chạy trên mọi hệ điều** (windows/linux/macos)
- **Hỗ trợ** nhiều ngôn ngữ lập trình như **C#**, **VB**, F#,.., các ngôn ngữ này được gọi là **"Managed code"**
    - Mỗi tập tin **.NET executable** được build được coi là 1 **.NET assembly**
    - **Mã nguồn** sẽ được **compile** ra dạng **Intermediate Language** (IL, MSIL, Managed Code, Common IL - CIL) thay vì native code như x86
        - Ngoài ra còn có **metadata** và **mainfest**
            - **Metadata** mô tả **thông tin** của .NET assembly **để CLR sử dụng** trong khi thực thi
            - **Mainfest** của tập tin .NET assembly chứa nhiều **thông tin tự mô tả** về yêu cầu môi trường, scope, security, reference tới các thư viện khác, khả năng thích và các thuộc tính khác của tập tin .NET assembly
    - **File build** được **thực thi** thông qua **Common Language Runtime (CLR) của .NET framework**
        - **CLR** có **nhiều chức năng** như garbage collection, type checking, exception handling,..
        - **CLR cần được cài đặt trên OS** để có thể thực thi chương trình build bằng .NET framework
- **.NET có "unmanaged code" runtime** để thực thi các tập tin phát triển bởi ngôn ngữ khác
    - Giúp **file .NET** có thể **sử dụng lại các thư viện** không sử dụng .NET 
    - **Gọi api hệ thống** qua các dll như kernel32.dll, user32.dll,..
    - **Programer cần tự quản lí** error, memory khi lập trình sử dụng unmanaged code

- **Framework Class Library (FCL)** là **thư viện** chứa sẵn **nhiều công cụ** (class, method, datatype,..) giúp việc lập trình **đơn giản và nhanh hơn**
    - Các thư viện này **nằm trong nhóm Base Class Library (BCL)**
    - Đa số code của **BCL chứa trong các dll mscorlib.dll, System.dll, System.Core.dll**
- **FCL** được **tổ chức** theo **namespaces**, khi lập trình sẽ **thêm thư viện vào .NET assembly** để sử dụng thông **qua keyword "using"**
    - Ví dụ using System.\*;, using System.Runtime.\*;
- **Quá trình build và thực thi .NET**
    - **Source code** (C#, VB,..) được compile ra file **.NET assembly chứa IL**, **metadata** và **mainfest** lưu trong định dạng PE (dll, exe,..)
        - **IL code**: Tương đương với mã **assembly** trên x86 nhưng dành cho **.NET framework** runtime
        - **Metadata**: Các thành phần **mô tả về .NET asmbly** như kiểu dữ liệu, phương thức,.. để **CLR đọc và thực thi IL code**
        - **Mainfest**: Thông tin về tập tin .NET được build ra
        - Tập tin build ra **có thể chứa cả Native code** của thư viện unmanaged code như c/c++
        - Mặc định **file sẽ được build mà không có CLR**, để thực thi được thì **môi trường thực thi phải được cài đặt sẵn CLR**
            - **“.NET Single File”** là tính năng đóng **gói cả CLR vào trong file .NET** được build ra
    - Khi thực thi, **CLR** chứa **Just-In-Time (JIT) compiler** sẽ thực hiện **compile IL ra mã native** trên memory để CPU thực thi
        - Một số compiler **có khả năng compile sẵn "managed code"** sang native code để tăng hiệu năng
- **Mã độc .NET phổ biến** vì
    - .**NET tương tác** được với các thành phần của **hệ điều hành**, đặc biệt là **Windows**
    - **Quá trình** viết mã độc **đơn giản** hơn, **nhanh** hơn, có khả năng **obfuscate** để làm khó việc phân tích
        - Mã độc có thể **kết hợp cả "unmanaged code" và "managed code"** trong 1 tập tin thực thi .NET để làm phức tạp quá trình phân tích
  
## Định dạng PE file của .NET executable
- Trong **PE header** của file .NET khi build ra sẽ **có thêm thông tin về CLR Header**
    - Thông tin về **CLR Header** nằm trong **Data Directory thứ 15 (.NET Directory)**
- CLR Header là cấu trúc **IMAGE_COR20_HEADER**, trong đó có 1 só thông tin quan trọng sau
    - **MetaData**: thông tin **RVA** trỏ tới **CLR MetaData** và **kích thước** của MetaData
    - **Flags**: các thuộc tính của tập tin .NET, một số thuộc tính đặc biệt:
        - **COMIMAGE_FLAGS_ILONLY**               =0x00000001   :  Binary chỉ chứa Managed code (IL Code)
        - **COMIMAGE_FLAGS_NATIVE_ENTRYPOINT**    =0x00000010   :  Entrypoint của binary sẽ trỏ tới native code
    - **EntryPointToken/EntryPointRVA**: tùy vào Flag COMIMAGE_FLAGS_NATIVE_ENTRYPOINT, trường này **chứa Token** (Managed code) hoặc **RVA** (native code) của entrypoint
- **MetaData** sẽ bao **gồm MetaData Header** và **dữ liệu**
    - MetaData **Header** **có 2 trường quan trọng**
        - **Signature**: Chứa giá trị **0x424A5342 (BSJB)** 
        - **Streams**: **Số lượng stream** trong Metadata
    - Theo **sau MetaData Header là Stream Header**
- **Stream header** là 1 mảng có **số lượng phần từ = trường Stream** trong metadata header
    - Mỗi **phần tử có 3 giá trị**
        - **Offset**: Offset **trỏ đến Stream data**, tính theo vị trí **bắt đầu MetaData**
        - **Size**: Kích thước của stream data
        - **Name**: là 1 **chuỗi chứa tên của stream**, **kích thước** của chuỗi được **làm tròn theo 1 dword (4 byte)**
    - Các stream đáng chú ý
        - **#~ Stream**:
            - Stream quan trọng **chứa MetaData Table**
        - **#Strings** Stream: 
            - Một mảng **chứa các chuỗi UTF8** sử dụng bởi metadata như tên class, phương thức, các trường..
            - **Được tham chiếu** trong MetaData Table **bởi offset của chuỗi tính từ điểm bắt đầu của stream #Strings**
        - **#US (User Strings)** Stream: 
            - Một mảng **chứa các chuỗi unicode**. 
            - **Bắt đầu bằng byte 0**, theo sau là giá trị 7 bit tương đương với **kích thước** của chuỗi tính theo byte và **chuỗi**. Mỗi string **kết thúc bằng 1 byte thêm** ở cuối.
        - **#Blob** Stream: 
            - “Binary Large Object” stream chứa dữ liệu dạng được sử dụng cho nhiều mục đích khác nhau như giá trị các trường, signature các phương thức,..
            - Được sử dụng trong MetaData Table 
- **Metadata table** chứa thông tin **các thành phần chính của .NET assembly** như class, interface, method, field,.. 
    - Thông tin tương ứng với **phiên bản CLR hỗ trợ** để có thể thực thi được tập tin .NET này
        - Các **chương trình .NET có thể tự xem**, kiểm tra **metadata** của **chính nó** và cả **các .NET assembly khác** trong **khi thực thi**
- **Các bảng** trong MetaData Table **có cấu trúc riêng** và chứa các thông tin đáng chú ý của .NET assembly
    - **TypeDef** Table: Tên, thuộc tính, kiểu dữ liệu của các class, interface 
    - **MethodDef** Table: Tên, tham số, thuộc tính, dữ liệu trả về và địa chỉ RVA của các phương thức
    - **FieldDef** Table: Kiểu dữ liệu, thuộc tính các trường (biến trong class)
    - **TypeRef** Table: Reference tới kiểu dữ liệu trong .NET assembly khác (thư viện FCL, class khác,..)
    - **MemberRef** Table: Reference tới các phương thức, thuộc tính,.. trong .NET assembly khác (thư viện FCL, class khác,..)
    - Assembly Table: Tên, phiên bản của file
    - **AssemblyRef** Table: Tên, phiên bản của các .NET assembly khác
    - Module Table: Tên và GUID của file
    - Param Table: Các tham số của các method
    - Constant Table: Giá trị các hằng số được dùng
- Mỗi **phần tử** trong các bảng của MetaData table được **mô tả dựa vào Metadata Unique Identifier (ID)** hay **Metadata Token**
    - **Token** là 1 **DWORD** mô tả về **bảng và index** của phần tử trong bảng đó. DWORD được chia làm 2 phần
        - **Token (8 bit)**: Gía trị để xác định bảng
        - **RID (RowIndex) (24 bit)**: Index trong bảng
    - Ví dụ Token **0x0600002C** mô tả phần tử nằm trong **bảng 0x06** và là phần tử thứ **0x00002C** trong bảng
    - **Token được CLR xác định** và dùng để **tương tác** với đúng các **dữ liệu trong metadata**
- **Method Table** mô tả **thông tin về các phương thức**, các thông tin bao gồm
    - **RVA (DWORD)**: Địa chỉ tương đối **so với imagebase** trỏ tới dữ liệu method khi load PE file lên memory
        - **Xác định offset** trỏ tới dữ liệu của phương thức bằng cách **convert từ RVA sang offset**
    - **ImplFlags (2byte)**: Thuộc tính của phương thức
    - **Flags (2byte)**
    - **Name**: **offset trong #String stream** chứa của **tên phương thức**
    - **Signature**: Offset trong #Blob stream chứa định nghĩa của phương thức
    - **ParamList**: Danh sách các tham số của phương thức
- Mỗi **method bao gồm 3** hoặc **tối thiểu 2** thành phần
    - Method **Header**
    - Phần **code của method (IL code)**
    - **Dữ liệu bổ sung**, tồn tại nếu được mô tả trong Header
- **Method header** được **định nghĩa bởi compiler** tùy thuộc vào độ phức tạp của phương thức. Có **2 dạng format** của method header:
    - **Tiny header**: 
        - Tối ưu cho các **phương thức có kích thước nhỏ**. **Header** chỉ gồm **1 byte**, gồm 2 trường
            - **Flag (2 bit)**: có giá trị **0x2** (**CorILMethod_TinyFormat**)
            - **Size (6 bit)**: kích thước code của method (tối đa 63 byte)
        - Được **áp dụng cho** các phương thức thỏa mãn điều kiện
            - Kích thước **< 64 byte** (tính cả 1 byte header)
            - **Không chứa biến cục bộ** và **SEH**
            - **maxstack < 8**
    - **Fat header**: 
        - **Header** chưa đầy đủ **nhiều thông tin về phương thức** hơn 
        - **Áp dụng** cho các **phương thức không lưu ở dạng tiny**
        - Header gồm các trường: 
            - **Flag (12 bit)**: có giá trị **0x3** (**CorILMethod_FatFormat**)
            - **Size (4 bit)**: **kích thước header** của header **tính theo DWORD** (hiện là **3 DWORD**)
            - **MaxStack**: Kích thước stack
            - **CodeSize**: Kích thước phần code của method
            - **LocalVarSigTok**: Token mô tả biến cục bộ của method lưu trong #Blob stream

# Phân tích .NET malware
- **Xác định** tập tin **PE .NET**
    - Sử dụng các công cụ **đọc thông tin PE file**: **CFF**, **petudio**, **die**
        - **Import 1 dll mscoree.dll** và các hàm
            - **_CorExeMain**
            - **_CoreDllMain**
        - **DIE** có thể xác định thông tin **linker/compiler** của .NET assembly
        - Dữ liệu từ **.NET Directory trong Data Direcotory**  của PE header 
    - Thông qua **các string**
        - **Tên stream**: ~#, **#Blob, #String**, #US,..
        - Tên **namespace**: **System.Runtime**.*
- Có thể **áp dụng** phương pháp **phân tích động** để xác định **hành vi, ioc**
- Khi **phân tích tĩnh**, sử dụng các **công cụ disassseble/decompile IL code** như: **ILSpy**, **dnspy**, dotpeek, reflector,..
- Các **file không bị làm rối** thường được **decompile với đầy đủ thông tin** theo dạng project
    - Việc **phân tích** tương đương với **đọc hiểu code** (ở dạng **C# hoặc IL code**) của theo các class trong project
    - Đối với các chương trình **exe** , có thể **bắt đầu phân tích từ Entrypoint**
    - Đối với các thư viện **dll**, cần **xác định method được gọi** để bắt đầu phân tích
        - **.NET loader** có thể **sử dụng** class **System.Reflection.Assembly** để load .NET assembly trong khi chạy
            - **LoadFrom/LoadFile** để **load file theo path**
            - **Load** để Load từ **dữ liệu trên memory**
        - **Sau khi load** assembly, loader **sử dụng GetType/GetMethod** để xác định phương thức muốn chạy và thực thi thông qua **Invoke**
    - Sử dụng tính năng **Analyze** để **tìm reference liên quan** đối với một số thuộc tính như **Filed**, **Method**,..
        - **Uses**: Các class, method, field được dùng bởi thuộc tính vừa phân tích
        - **Used by**: Các class, method, field gọi tới thuộc tính vừa phân tích
- **Mã độc có thể obfuscate** để việc decompile khó hơn
    - Sử dụng **chuỗi kí tự unicode** để đặt tên **method**, tên **field**, **properties** 
    - **Làm rối flow** thông qua if else, switch case
    - **Mã hóa, encode** các dữ liệu, string
    - Một số packer phổ biến: .NET Reactor, **ConfuserEX**,..
    - Có thể **sử dụng công cụ deobfuscate** như **de4dot**
        - Nếu deobfuscate thành công, có thể thực hiện phân tích luôn
    - **Xác định** và tìm kiếm các công cụ deobfuscate với từng **obfuscator**
- **Phân tích** khi các obfuscator **không hỗ trợ deobfuscate hoàn toàn**
    - Sử dụng **de4dot để đổi tên** các method, field,.. về dạng thông thường (method_1, field_1,.._)
    - Mã độc thường **sử dụng** phương thức **.cctor** (static constructor, type constructor, class constructor .cctor) để thực hiện **decrypt, decode phần body** hoặc **.NET assembly khác** để thực thi
    - Sử dụng **debugger** để đặt **breakpoint** tại các đoạn code thích hợp và **kiểm tra dữ liệu** khi dừng 
        - Đặt **bp tại các đoạn code gọi đến method** và **kiểm tra tham số, giá trị trả về**
            - Sử dụng cửa sổ **Locals**, **Auto** để xem các biến
            - Sử dụng cửa sổ **Watch** để theo dõi các biến
                - Có thể **sử dụng code trong Watch** để **gọi các hàm, phương thức của .NET assembly** đang debug
    - **Chú ý** các đoạn code sử dụng **byte array**, thường chứa dữ liệu sau khi deobfuscate
        - Mã độc có thể sử dụng các **phương thức mã hóa** XOR, AES, RC4,.. để giải mã
        - Các **string** có thể được **decode** thông qua **Base64**, **Replace**, **Reverse**,..
    - Mã độc có thể **lưu trữ và sử dụng các resource** trong quá trình giải mã, đặc biệt là các **resource có entropy cao**
    - **Sau khi decrypt** dữ liệu **.NET assembly trên memory**, mã độc sử dụng **System.Reflection.Assembly, System.Reflection.MethodInfo, Invoke,..** để load và thực thi 
    - Chú ý việc **sử dụng native code** gọi window api
        - **Keyword \[DllImport("\[Dll_name\]")\]**
        - API detect debuger, vm, sandbox
        - API memory management
        - APT mã hóa, giải mã

# Tài liệu tham khảo
- https://intezer.com/blog/incident-response/intro-to-malware-net-executable-file/
- https://www.codeproject.com/Articles/12585/The-NET-File-Format
- https://www.sans.org/webcasts/silly-framework-intro-analyzing-dotnet-malware-sansatmic-sydney-117015
